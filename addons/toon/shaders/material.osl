/*
 * toon shader
 * author: gnya
 */

#include "group_id.h"
#include "shadow.h"

#define MAX_LOOP 50

/*
 * This function checks whether lights from the direction of
 * a given light source reaches the point of current interest.
 */
int shadow(vector L, float cutoff, float eps) {
    vector pos = P + ray_offset(L, cutoff);

    int this_group = 0;
    int this_props = 0;  // Unused.

    get_this_shadow_group(this_group, this_props);

    int max_loop = MAX_LOOP;
    int count = 0;

    int hit_group = 0;
    int hit_props = 0;

    int this_backfacing = dot(Ng, L) < 0.0;

    for (; count < max_loop && trace(pos, L); count++) {
        get_hit_shadow_group(hit_group, hit_props);

        if (this_group == 0 || this_group != hit_group) {
            if (hit_props == 0) {
                return 1;
            } else if (hit_props == 1 && !this_backfacing) {
                return 1;
            }
        }

        getmessage("trace", "P", pos);
        pos += L * eps;
    }

    if (count == max_loop) {
        warning("the max loop has been reached.");
    }

    return 0;
}

shader material(
    vector Light = vector(0.0, 0.0, 0.0)
    [[ string widget = "null" ]],
    float Cutoff = 0.1,
    float Reflectance = 0.5,
    float Exponent = 10.0,

    /*
     * This is a hack necessary to determine whether the currently
     * used renderer can use OSL and perform fallback processing.
     */
    output int IsCycles = 1
    [[ string widget = "boolean" ]],

    output float Diffuse = 0.0,
    output float Specular = 0.0
) {
    Diffuse = clamp(dot(Light, N), 0.0, 1.0);

    if (Reflectance != 0.0) {
        vector R = reflect(normalize(Light), N);
        
        Specular = pow(max(0.0, dot(-I, R)), Exponent) * Reflectance;
    }

    if (Diffuse != 0.0) {
        vector L = normalize(Light);

        if (shadow(L, Cutoff, 1.0e-4)) {
            Diffuse = 0.0;
            Specular = 0.0;
        }
    }
}
