/*
 * This function calculates the amount by which the ray start
 * point is moved along the geometry normal. This is based on
 * the shadow terminator setting in cycles, but is not perfect
 * due to limitation of OSL functionality.
 * ref: https://github.com/blender/.../cycles/kernel/light/sample.h
 */
vector ray_offset(vector L, float cutoff, float eps0, float eps1) {
    if (cutoff == 0.0) {
        return vector(0.0);
    }

    float NL = dot(N, L);
    int transmit = NL < 0.0;
    
    NL = abs(NL);
    
    vector n = transmit ? -Ng : Ng;
    float nL = dot(n, L);
    
    float offset = 0.0;
    float eps = transmit ? eps1 : eps0;
    
    if (NL < cutoff) {
        offset = clamp(2.0 - (nL + NL) / cutoff, 0.0, 1.0);
    } else {
        offset = clamp(1.0 - nL / cutoff, 0.0, 1.0);
    }
    
    return n * offset * eps;
}

/*
 * This function checks whether lights from the direction of
 * a given light source reaches the point of current interest.
 */
int shadow(vector L, float cutoff, float eps) {
    vector offset = ray_offset(L, cutoff, 5.0e-4, 1.0e-5);
    vector pos = P + offset + Ng * eps; // TODO check this
    
    float this_obj_id = 0.0;
    getattribute("object:index", this_obj_id);
    
    if (this_obj_id == 0.0) {
        return trace(pos, L);
    }
    
    int max_loop = 50;
    int count = 0;
    float hit_obj_id = 0.0;
    vector ng = Ng;
    
    for (; count < max_loop & trace(pos, L); count++) {
        getmessage("trace", "object:index", hit_obj_id);

        if (hit_obj_id != this_obj_id) {
            return 1;
        }
        
        getmessage("trace", "P", pos);
        // If the ray hits a backface, it returns the inverse normal.
        getmessage("trace", "Ng", ng);
        pos -= ng * eps;
    }
    
    if (count == max_loop) {
        warning("the max loop has been reached.");
    }
    
    return 0;
}

/*
 * This function calculates how reflective other objects appear
 * at the current point of interest.
 */
float mirror(float distance, float factor, float cutoff, float eps) {
    float r = 0.0;
    vector dir = reflect(-I, N);

    if (trace(P + Ng * eps, dir)) {
        vector n = 0.0;
        getmessage("trace", "N", n);

        if (abs(dot(dir, n)) > cutoff) {
            float p_dist = 0.0; // distance from rendering point
            float s_dist = 0.0; // distance from rendering surface
            getmessage("trace", "hitdist", p_dist);
            s_dist = dot(I, N) * p_dist;

            r = (distance - s_dist) / distance;
            r = pow(clamp(r, 0.0, 1.0), 2.0) * factor;
        }
    }

    return r;
}

shader toon(
    vector LightStrength = vector(0.0, 0.0, 1.0)
    [[ string widget = "null" ]],
    int UseHighlight = 0
    [[ string widget = "boolean" ]],
    int UseShade = 1
    [[ string widget = "boolean" ]],
    int UseHalfLambert = 0
    [[ string widget = "boolean" ]],
    int UseShadow = 1
    [[ string widget = "boolean" ]],
    int UseMirror = 0
    [[ string widget = "boolean" ]],
    int UseTransparent = 0
    [[ string widget = "boolean" ]],
    int UseTransparentCulling = 1
    [[ string widget = "boolean" ]],
    float HighlightThreshold = 0.9,
    float HighlightMap = 0.0,
    float ShadowThreshold = 0.1,
    float ShadowCutoff = 0.05,
    float ShadeMap = 1.0,
    float MirrorFactor = 0.5,
    float MirrorDistance = 100.0,
    color HighlightColor = color(1.0),
    color BaseColor = color(0.5),
    color ShadowColor = color(0.1),
    float HighlightTransparency = 1.0,
    float Transparency = 1.0,
    output closure color Toon = transparent()
) {
    float l_str = length(LightStrength) / M_PI;
    vector L = normalize(LightStrength);

    float d = ShadeMap; // diffuse

    if (UseShade) {
        if (UseHalfLambert) {
            d *= (0.5 * dot(L, N) + 0.5) * l_str;
        } else {
            d *= max(0.0, dot(L, N)) * l_str;
        }
    }

    if (UseShadow & shadow(L, ShadowCutoff, 1.0e-4)) {
        d = 0.0;
    }
    
    float h = 0.0; // highlight

    if (UseHighlight) {
        h = dot(-I, reflect(L, N));
        h += HighlightMap; // apply highlight map
    }

    color c = BaseColor;
    
    if (d <= ShadowThreshold) {
        c = ShadowColor;
    } else if (h > HighlightThreshold) {
        c = HighlightColor;
    }

    float r = 0.0; // reflection

    if (UseMirror) {
        r = mirror(MirrorDistance, MirrorFactor, 0.05, 1.0e-4);
    }

    float t = 1.0; // transparency

    if (UseTransparent) {
        t = Transparency;

        if (d <= ShadowThreshold) {
        } else if (h > HighlightThreshold) {
            t = HighlightTransparency;
        }

        if (UseTransparentCulling) {
            int t_depth = 0;
            getattribute("path:transparent_depth", t_depth);

            t *= t_depth == 0;
        }
    }

    Toon = mix(c * emission(), reflection(N), r);
    Toon = mix(transparent(), Toon, t);
}